using SdkLang.Langs;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using net.r_eg.Conari;
using net.r_eg.Conari.Core;
using net.r_eg.Conari.Native;
using net.r_eg.Conari.Types;

namespace SdkLang.Utils
{
    public static class PrintHelper
    {
        public static string GetFileHeader(List<string> pragmas, List<string> includes, bool isHeaderFile)
        {
            var genInfo = Main.GenInfo;
            var sb = new StringBuilder();

            // Pragmas
            if (isHeaderFile)
            {
                sb.Append("#pragma once\n");
                if (pragmas.Count > 0)
                    foreach(string i in pragmas) { sb.Append("#pragma " + i + "\n"); }
                sb.Append("\n");
            }

            if (genInfo.IsExternal)
                sb.Append("#include \"../Memory.h\"\n");

            // Includes
            if (includes.Count > 0)
                foreach (string i in includes) { sb.Append("#include " + i + "\n"); }
            sb.Append("\n");

            // 
            sb.Append($"// Name: {genInfo.GameName}, Version: {genInfo.GameVersion}\n\n");
            sb.Append($"#ifdef _MSC_VER\n\t#pragma pack(push, 0x{genInfo.MemberAlignment:X2})\n#endif\n\n");
            sb.Append($"namespace {genInfo.NamespaceName}\n{{\n");

            return sb.ToString();
        }

        public static string GetFileFooter()
        {
            return "}\n\n#ifdef _MSC_VER\n\t#pragma pack(pop)\n#endif\n";
        }

        public static string SaveSdkHeader()
        {
            string ret = 
                $"// ------------------------------------------------\n" +
                $"// Sdk Generated By ( Unreal Finder Tool By CorrM )\n" +
                $"// ------------------------------------------------\n" +
                $"#pragma once\n\n" +
                $"// Name: {Main.GenInfo.GameName}, Version: {Main.GenInfo.GameVersion}\n\n" +
                $"#include <set>\n" +
                $"#include <string>\n";

            return ret;
        }

        public static JsonStruct GetStruct(string structName)
        {
            using (var l = new ConariL(Main.UftPath))
            {
                var d = l.DLR;
                IntPtr structPtr = d.GetStructPtr<IntPtr>(new UnmanagedString(structName, UnmanagedString.SType.Ansi).Pointer);
                l.BeforeUnload += (sender, e) => { d.FreeStructPtr(structPtr); };

                var us = new UnmanagedStructure(structPtr, typeof(Native.JsonStruct));
                var jStruct = (Native.JsonStruct)us.Managed;

                JsonStruct ret = new JsonStruct()
                {
                    Name = jStruct.StructName.ToString(),
                    Super = jStruct.StructSuper.ToString(),
                    Size = jStruct.MembersCount,
                    Members = new List<JsonVar>()
                };

                CTypes.UftArrayPtr membersArray = new CTypes.UftArrayPtr(jStruct.Members, jStruct.MembersCount, jStruct.MemberSize);

                for (int i = 0; i < membersArray.Count; i++)
                {
                    var nVar = (Native.JsonVar)Marshal.PtrToStructure(membersArray[i], typeof(Native.JsonVar));
                    ret.Members.Add(new JsonVar() { Name = nVar.Name.ToString(), Offset = nVar.Offset, Size = nVar.Size, Type = nVar.Type.ToString() });
                }
                return ret;
            }
        }
    }
}
